struct Complex {
    r: Real
    i: Real
}

fn cMul(a: Complex, b: Complex): Complex {
    realComp := a.r * b.r - a.i * b.i
    imagComp := a.r * b.i + a.i * b.r

    return Complex{realComp, imagComp}
}

fn cAdd(a: Complex, b: Complex): Complex {
    realComp := a.r + b.r
    imagComp := a.i + b.i

    return Complex{realComp, imagComp}
}

fn mandelbrot(a: Complex): Int {
    const ITERS := 50
    z := Complex{0., 0.}
    for (i := 0 to ITERS) {
        z = z.cMul(z).cAdd(a)
        if ((z.r*z.r + z.i*z.i) > 4.0) {
            return i
        }
    }
    return ITERS
}

fn sin(x: Real): Real {

    const _PI: Real = 3.14159265359
    const precision: Int = 60

    sign: Int = -1
    x1 := x mod (2. * _PI)

    term: Real = 1.0
    sum: Real = 0.0

    for (iter: Int = 1 to precision) {
        term = term * (x1 / (iter as Real))
        if (iter mod 4 == 1) {
            sum = sum + term
        }
        if (iter mod 4 == 3) {
            sum = sum - term
        }
    }
    return sum
}

fn cos(x: Real): Real {
    const _PI: Real = 3.14159265359
    return sin(x + _PI)
}

struct Color {
    r: Real
    g: Real
    b: Real
}

fn toColor(i: Int): Color {
    if (i >= 50) {
        return Color{0., 0., 0.}
    }

    a := (i as Real) * 0.2

    r := (sin(a) + 1.)/2.
    g := (sin(a + 2.1) + 1.)/2.
    b := (sin(a + 4.2) + 1.)/2.

    return Color{r, g, b}
}

fn writeStr(f: File, s: String) {
    for (c in s) {
        f.writeChar(c)
    }
}

fn reverse(i: Int): Int {
    r: Int = 0
    sum: Int = 0
    n := i
    while (n > 0) {
        r = n mod 10
        sum = (sum * 10) + r
        n = n / 10
    }
    return sum
}

fn writeInt(f: File, i: Int) {
    if (i == 0) {
        f.writeChar('0')
        return ()
    }
    n := reverse(i)
    while (n > 0) {
        r := n mod 10
        f.writeChar((r + 48) as Char)
        n = n / 10
    }
}

fn writeCol(f: File, col: Color, maxVal: Int) {
    f.writeInt((col.r * maxVal) as Int)
    f.writeChar(' ')
    f.writeInt((col.g * maxVal) as Int)
    f.writeChar(' ')
    f.writeInt((col.b * maxVal) as Int)
    f.writeChar('\n')
}

fn main() {
    const FORMAT := "P3"
    const WIDTH := 256
    const HEIGHT := 128
    const MAX_VAL := 255

    f := open("uv.ppm", "w")
    f.writeStr(FORMAT)
    f.writeChar('\n')
    f.writeInt(WIDTH)
    f.writeChar('\n')
    f.writeInt(HEIGHT)
    f.writeChar('\n')
    f.writeInt(MAX_VAL)
    f.writeChar('\n')

    yStep := 2. / HEIGHT
    xStep := 2.5 / WIDTH

    for (y := -1.0 to 1.05 by yStep) {
        for (x := -2.0 to 0.5 by xStep) {
            f.writeCol(mandelbrot(Complex{x, y}).toColor(), MAX_VAL)
        }
    }
    f.close()
}